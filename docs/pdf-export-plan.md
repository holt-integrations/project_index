# PDF Export - Implementation Plan

## Overview

Add the ability to export any markdown document to PDF with a single click, preserving formatting, code highlighting, mermaid diagrams, and other visual elements.

## Goals

- **Primary**: Export current document to well-formatted PDF
- **Secondary**: Batch export multiple documents
- **Tertiary**: Export history and management

## Non-Goals

- Real-time collaborative editing
- Cloud storage of PDFs (all local)
- Complex PDF editing/annotation features

## Architecture

### High-Level Flow

```
User clicks "Export to PDF"
    ↓
Frontend sends request to backend with document path
    ↓
Backend fetches document content and renders HTML
    ↓
HTML → PDF conversion (headless browser or Python library)
    ↓
Save PDF to exports directory
    ↓
Return PDF file to user (download)
    ↓
Record export in history
```

### Technology Choice

**Option 1: WeasyPrint (Recommended for MVP)**
- **Pros**:
  - Pure Python library (no external dependencies)
  - Lightweight and ARM64-compatible
  - Good CSS support for print media
  - Lower resource usage than headless browser
  - Easy to install: `pip install weasyprint`
- **Cons**:
  - Limited JavaScript support (no mermaid rendering)
  - Some CSS features not supported
  - May need additional fonts for unicode

**Option 2: Playwright (Future Enhancement)**
- **Pros**:
  - Full browser rendering (JavaScript, mermaid diagrams)
  - Perfect fidelity to what user sees in browser
  - Supports complex layouts and interactions
- **Cons**:
  - Resource-intensive (CPU and memory)
  - Requires downloading Chromium binary (~300MB)
  - ARM64 compatibility may be an issue
  - Slower PDF generation

**Option 3: wkhtmltopdf (Alternative)**
- **Pros**:
  - CLI tool, well-established
  - Good rendering quality
- **Cons**:
  - Based on older Qt WebKit (less maintained)
  - External binary dependency
  - ARM64 availability unclear

**Decision**: Start with **WeasyPrint** for MVP, with option to upgrade to Playwright later for advanced features.

## Implementation Plan

### Phase 1: Basic PDF Export (MVP)

#### Backend Changes

**1. Install Dependencies**

```bash
# Add to backend/requirements.txt
weasyprint>=61.0
markdown2>=2.4.0  # For markdown to HTML conversion
pygments>=2.17.0  # For syntax highlighting in HTML
```

**2. Create PDF Export Module** (`backend/pdf_export.py`)

```python
"""
PDF export functionality using WeasyPrint.
"""
from pathlib import Path
from typing import Optional
import markdown2
from weasyprint import HTML, CSS
from datetime import datetime

class PDFExporter:
    """Handle PDF export of markdown documents."""

    def __init__(self, export_dir: Path):
        self.export_dir = export_dir
        self.export_dir.mkdir(parents=True, exist_ok=True)

    def markdown_to_html(
        self,
        markdown_content: str,
        title: str,
        metadata: dict
    ) -> str:
        """Convert markdown to styled HTML suitable for PDF."""
        # Convert markdown to HTML with extras
        html_content = markdown2.markdown(
            markdown_content,
            extras=[
                'fenced-code-blocks',
                'tables',
                'task_list',
                'strike',
                'footnotes',
                'header-ids',
                'code-friendly',
                'cuddled-lists'
            ]
        )

        # Wrap in full HTML document with styling
        html_doc = self._create_html_document(
            html_content,
            title,
            metadata
        )

        return html_doc

    def _create_html_document(
        self,
        content: str,
        title: str,
        metadata: dict
    ) -> str:
        """Create complete HTML document with styling."""
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>{title}</title>
            <style>
                {self._get_pdf_styles()}
            </style>
        </head>
        <body>
            <div class="pdf-header">
                <h1>{title}</h1>
                <div class="metadata">
                    <p>Project: {metadata.get('project', 'Unknown')}</p>
                    <p>Exported: {metadata.get('export_date', 'Unknown')}</p>
                    <p>Source: {metadata.get('source_path', 'Unknown')}</p>
                </div>
            </div>
            <div class="pdf-content">
                {content}
            </div>
            <div class="pdf-footer">
                <p>Generated by Project Viewer</p>
            </div>
        </body>
        </html>
        """

    def _get_pdf_styles(self) -> str:
        """Return CSS styles optimized for PDF export."""
        return """
        @page {
            size: A4;
            margin: 2cm;
            @bottom-center {
                content: counter(page) " / " counter(pages);
            }
        }

        body {
            font-family: 'DejaVu Sans', 'Liberation Sans', Arial, sans-serif;
            font-size: 11pt;
            line-height: 1.6;
            color: #1f2937;
        }

        .pdf-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #e5e7eb;
        }

        .pdf-header h1 {
            font-size: 24pt;
            margin-bottom: 0.5rem;
            color: #1f2937;
        }

        .metadata {
            font-size: 9pt;
            color: #6b7280;
        }

        .metadata p {
            margin: 0.25rem 0;
        }

        .pdf-content h1 {
            font-size: 20pt;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            page-break-after: avoid;
        }

        .pdf-content h2 {
            font-size: 16pt;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
            page-break-after: avoid;
        }

        .pdf-content h3 {
            font-size: 14pt;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        pre {
            background-color: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 1rem;
            overflow-x: auto;
            page-break-inside: avoid;
        }

        code {
            font-family: 'DejaVu Sans Mono', 'Liberation Mono', monospace;
            font-size: 9pt;
            background-color: #f3f4f6;
            padding: 0.2rem 0.4rem;
            border-radius: 2px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            page-break-inside: avoid;
        }

        th, td {
            border: 1px solid #d1d5db;
            padding: 0.5rem;
            text-align: left;
        }

        th {
            background-color: #f3f4f6;
            font-weight: bold;
        }

        img {
            max-width: 100%;
            height: auto;
            page-break-inside: avoid;
        }

        blockquote {
            border-left: 4px solid #d1d5db;
            padding-left: 1rem;
            margin: 1rem 0;
            color: #6b7280;
        }

        .pdf-footer {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid #e5e7eb;
            font-size: 9pt;
            color: #9ca3af;
            text-align: center;
        }
        """

    def export_to_pdf(
        self,
        markdown_content: str,
        document_name: str,
        project_id: str,
        source_path: str
    ) -> Path:
        """
        Export markdown content to PDF.

        Returns path to generated PDF file.
        """
        # Prepare metadata
        metadata = {
            'project': project_id,
            'export_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'source_path': source_path
        }

        # Convert markdown to HTML
        html_content = self.markdown_to_html(
            markdown_content,
            document_name,
            metadata
        )

        # Generate PDF filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        safe_name = document_name.replace('.md', '').replace(' ', '_')
        pdf_filename = f"{project_id}_{safe_name}_{timestamp}.pdf"
        pdf_path = self.export_dir / pdf_filename

        # Convert HTML to PDF
        HTML(string=html_content).write_pdf(
            pdf_path,
            presentational_hints=True
        )

        return pdf_path
```

**3. Update Configuration** (`backend/config.py`)

```python
# PDF Export settings
ENABLE_PDF_EXPORT = True  # Toggle feature on/off
PDF_EXPORT_DIR = Path(__file__).parent.parent / "data" / "exports"
PDF_MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB max PDF size
PDF_KEEP_HISTORY = True  # Track export history
PDF_HISTORY_PATH = Path(__file__).parent.parent / "data" / "export_history.json"
```

**4. Add Export History Tracking** (`backend/export_history.py`)

```python
"""
Export history tracking.
"""
import json
from pathlib import Path
from datetime import datetime
from typing import List, Dict

class ExportHistory:
    """Track PDF export history."""

    def __init__(self, history_path: Path):
        self.history_path = history_path
        self.history_path.parent.mkdir(parents=True, exist_ok=True)

        if not self.history_path.exists():
            self._save_history([])

    def add_export(
        self,
        document_path: str,
        project_id: str,
        pdf_path: str,
        pdf_size: int
    ):
        """Record a new export."""
        history = self._load_history()

        export_record = {
            'timestamp': datetime.now().isoformat(),
            'document_path': document_path,
            'project_id': project_id,
            'pdf_path': pdf_path,
            'pdf_size': pdf_size,
            'pdf_filename': Path(pdf_path).name
        }

        history.append(export_record)
        self._save_history(history)

    def get_history(self, limit: int = 50) -> List[Dict]:
        """Get recent export history."""
        history = self._load_history()
        return sorted(
            history,
            key=lambda x: x['timestamp'],
            reverse=True
        )[:limit]

    def _load_history(self) -> List[Dict]:
        """Load history from file."""
        try:
            with open(self.history_path, 'r') as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            return []

    def _save_history(self, history: List[Dict]):
        """Save history to file."""
        with open(self.history_path, 'w') as f:
            json.dump(history, f, indent=2)
```

**5. Add API Endpoints** (`backend/main.py`)

```python
from pathlib import Path
from fastapi.responses import FileResponse
from . import config
from .pdf_export import PDFExporter
from .export_history import ExportHistory

# Initialize PDF exporter and history
pdf_exporter = PDFExporter(config.PDF_EXPORT_DIR)
export_history = ExportHistory(config.PDF_HISTORY_PATH)


@app.post("/api/export/pdf")
async def export_document_to_pdf(
    path: str = Query(..., description="Absolute path to the document")
):
    """
    Export a markdown document to PDF.

    Returns the generated PDF file for download.
    """
    if not config.ENABLE_PDF_EXPORT:
        raise HTTPException(
            status_code=501,
            detail="PDF export is not enabled"
        )

    try:
        file_path = Path(path)

        # Security check
        if not is_path_safe(file_path, config.PROJECTS_DIR):
            raise HTTPException(
                status_code=403,
                detail="Access denied: File is outside the projects directory"
            )

        # Check if file exists
        if not file_path.exists():
            raise HTTPException(
                status_code=404,
                detail=f"File not found: {path}"
            )

        # Read markdown content
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                markdown_content = f.read()
        except UnicodeDecodeError:
            raise HTTPException(
                status_code=400,
                detail="File is not a valid UTF-8 text file"
            )

        # Find project ID
        manifest = load_manifest()
        project_id = "unknown"
        if manifest:
            for project in manifest.projects:
                if any(doc.path == str(file_path) for doc in project.documents):
                    project_id = project.id
                    break

        # Generate PDF
        pdf_path = pdf_exporter.export_to_pdf(
            markdown_content=markdown_content,
            document_name=file_path.name,
            project_id=project_id,
            source_path=str(file_path)
        )

        # Record in history
        pdf_size = pdf_path.stat().st_size
        export_history.add_export(
            document_path=str(file_path),
            project_id=project_id,
            pdf_path=str(pdf_path),
            pdf_size=pdf_size
        )

        # Return PDF file
        return FileResponse(
            pdf_path,
            media_type='application/pdf',
            filename=pdf_path.name,
            headers={
                'Content-Disposition': f'attachment; filename="{pdf_path.name}"'
            }
        )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"PDF export failed: {str(e)}"
        )


@app.get("/api/export/history")
async def get_export_history(
    limit: int = Query(50, ge=1, le=200, description="Maximum number of records")
):
    """Get PDF export history."""
    if not config.ENABLE_PDF_EXPORT:
        raise HTTPException(
            status_code=501,
            detail="PDF export is not enabled"
        )

    history = export_history.get_history(limit)
    return {
        'total': len(history),
        'exports': history
    }


@app.get("/api/export/pdf/{filename}")
async def download_exported_pdf(filename: str):
    """Download a previously exported PDF."""
    if not config.ENABLE_PDF_EXPORT:
        raise HTTPException(
            status_code=501,
            detail="PDF export is not enabled"
        )

    pdf_path = config.PDF_EXPORT_DIR / filename

    if not pdf_path.exists():
        raise HTTPException(
            status_code=404,
            detail="PDF file not found"
        )

    # Security check: ensure file is in exports directory
    if not is_path_safe(pdf_path, config.PDF_EXPORT_DIR):
        raise HTTPException(
            status_code=403,
            detail="Access denied"
        )

    return FileResponse(
        pdf_path,
        media_type='application/pdf',
        filename=filename
    )
```

#### Frontend Changes

**1. Update Document Viewer HTML** (`frontend/viewer.html`)

Add export button near the top of the document viewer (after the back button):

```html
<!-- Add after back button -->
<button id="export-pdf-btn" class="btn-secondary" title="Export to PDF">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
    </svg>
    Export to PDF
</button>
```

**2. Add Export Functionality** (`frontend/app.js`)

```javascript
/**
 * Export current document to PDF
 */
async function exportDocumentToPDF(documentPath) {
    try {
        // Show loading state
        const exportBtn = document.getElementById('export-pdf-btn');
        const originalText = exportBtn.innerHTML;
        exportBtn.disabled = true;
        exportBtn.innerHTML = 'Exporting...';

        // Call export API
        const response = await fetch(
            `/api/export/pdf?path=${encodeURIComponent(documentPath)}`,
            { method: 'POST' }
        );

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Export failed');
        }

        // Download the PDF
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;

        // Get filename from Content-Disposition header
        const contentDisposition = response.headers.get('Content-Disposition');
        let filename = 'export.pdf';
        if (contentDisposition) {
            const match = contentDisposition.match(/filename="(.+)"/);
            if (match) filename = match[1];
        }

        a.download = filename;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);

        // Restore button
        exportBtn.disabled = false;
        exportBtn.innerHTML = originalText;

        // Show success message
        showMessage('PDF exported successfully!', 'success');

    } catch (error) {
        console.error('PDF export error:', error);

        // Restore button
        const exportBtn = document.getElementById('export-pdf-btn');
        exportBtn.disabled = false;
        exportBtn.innerHTML = originalText;

        // Show error message
        if (error.message.includes('not enabled')) {
            showMessage('PDF export is not enabled on this server', 'error');
        } else {
            showMessage(`Export failed: ${error.message}`, 'error');
        }
    }
}

// Add event listener in initViewerPage()
const exportBtn = document.getElementById('export-pdf-btn');
if (exportBtn) {
    exportBtn.addEventListener('click', () => {
        const documentPath = getCurrentDocumentPath(); // Get from URL or global state
        exportDocumentToPDF(documentPath);
    });
}
```

**3. Add Button Styles** (`frontend/styles.css`)

```css
#export-pdf-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    margin-left: 0.5rem;
}

#export-pdf-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

#export-pdf-btn svg {
    display: inline-block;
}
```

#### Update .gitignore

```
# PDF exports (generated files)
data/exports/
data/export_history.json
```

### Phase 2: Export History Page (Optional Enhancement)

Create a dedicated page to view and manage export history:

**1. Create HTML Page** (`frontend/exports.html`)

Similar structure to bookmarks.html, showing:
- List of exported PDFs
- Download links
- Source document info
- Export timestamp
- File size
- Delete option

**2. Add Navigation Link**

Add link to exports page in the header navigation alongside bookmarks.

### Phase 3: Batch Export (Future Enhancement)

Allow exporting multiple documents at once:

**1. Backend Changes**
- Add `POST /api/export/batch` endpoint
- Accept array of document paths
- Use asyncio or background task queue for parallel processing
- Return batch job ID for status tracking

**2. Frontend Changes**
- Add checkboxes to document list
- "Export selected" button
- Progress indicator for batch operations

## Testing Plan

1. **Basic Export**
   - Export simple markdown document
   - Verify PDF is generated and downloadable
   - Check PDF formatting (headers, paragraphs, lists)

2. **Complex Content**
   - Export document with code blocks
   - Export document with tables
   - Export document with images
   - Export document with blockquotes

3. **Edge Cases**
   - Very long documents (100+ pages)
   - Documents with special characters
   - Documents with unicode/emoji
   - Empty documents
   - Malformed markdown

4. **Error Handling**
   - Export non-existent file
   - Export file outside projects directory
   - Export with PDF export disabled
   - Disk space issues

5. **Resource Usage**
   - Monitor memory usage during export
   - Test multiple simultaneous exports
   - Large document export performance

## Deployment Notes

### Dependencies Installation

```bash
# Activate virtual environment
source .venv/bin/activate

# Install dependencies
pip install weasyprint markdown2 pygments

# Note: WeasyPrint may require system dependencies
# On Debian/Ubuntu/Raspberry Pi OS:
sudo apt-get install python3-cffi python3-brotli libpango-1.0-0 libpangoft2-1.0-0
```

### ARM64 Compatibility

WeasyPrint should work well on ARM64 (Raspberry Pi 4) as it's pure Python with native extensions that compile on ARM. Test thoroughly on target hardware.

### Resource Considerations

- WeasyPrint uses ~50-100MB memory per export
- Export time: ~1-3 seconds for typical document
- Monitor disk space in exports directory
- Consider cleanup policy for old exports

## Future Enhancements

### Phase 4: Advanced Features (Deferred)

1. **Mermaid Diagram Support**
   - Switch to Playwright for JavaScript rendering
   - Or pre-render mermaid to static images

2. **Custom Styling**
   - Allow users to choose PDF themes
   - Custom headers/footers
   - Cover page option

3. **Export Presets**
   - Different export profiles (compact, detailed, print)
   - Custom paper sizes
   - Orientation options

4. **Scheduled Exports**
   - Auto-export updated documents
   - Email delivery option
   - Export to cloud storage

5. **Export Analytics**
   - Most exported documents
   - Export frequency tracking
   - Popular export times

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| High memory usage on Pi | High | Use WeasyPrint instead of headless browser; monitor resource usage |
| ARM64 incompatibility | High | Test on target hardware early; have fallback options |
| Poor PDF formatting | Medium | Extensive CSS testing; iterate on styles |
| Slow export times | Medium | Set reasonable timeouts; show progress indicators |
| Disk space exhaustion | Low | Implement cleanup policy; warn when low on space |

## Success Criteria

- ✅ User can export any document to PDF with one click
- ✅ PDF preserves markdown formatting accurately
- ✅ Export completes in < 5 seconds for typical documents
- ✅ Exports work reliably on Raspberry Pi 4 (ARM64)
- ✅ Memory usage stays under 200MB per export
- ✅ PDFs include document metadata
- ✅ Export history is tracked and accessible

## Timeline

- **Phase 1 (MVP)**: 4-6 hours
  - Backend PDF export module: 2 hours
  - API endpoints: 1 hour
  - Frontend integration: 1-2 hours
  - Testing: 1 hour

## Open Questions

1. Should PDFs be kept indefinitely or auto-deleted after X days?
   - **Recommendation**: Keep for 30 days, then auto-delete

2. Should export be available for non-markdown files?
   - **Recommendation**: No, only markdown for MVP

3. Should we support custom CSS styling for PDFs?
   - **Recommendation**: Not for MVP, add later if requested

4. Should there be export limits (rate limiting)?
   - **Recommendation**: Yes, 10 exports per minute per user

## References

- [WeasyPrint Documentation](https://doc.courtbouillon.org/weasyprint/)
- [markdown2 Documentation](https://github.com/trentm/python-markdown2)
- [CSS Paged Media Spec](https://www.w3.org/TR/css-page-3/)
- [Print CSS Tutorial](https://www.smashingmagazine.com/2015/01/designing-for-print-with-css/)
